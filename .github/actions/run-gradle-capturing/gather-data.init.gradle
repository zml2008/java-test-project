initscript {
  repositories {
    maven {
      name 'jenkins-repo'
      url 'https://repo.jenkins-ci.org/releases/'
      mavenContent {
        releasesOnly()
        includeGroup 'edu.hm.hafner'
      }
    }
    mavenCentral()
  }

  dependencies {
    classpath "edu.hm.hafner:analysis-model:10.9.0"
  }
}

// Collect paths
def projectDirs = java.util.concurrent.ConcurrentHashMap.newKeySet()
def testExecutions = java.util.concurrent.ConcurrentHashMap.newKeySet()
def checkstyleReports = java.util.concurrent.ConcurrentHashMap.newKeySet()
def reviewdogJsons = java.util.concurrent.ConcurrentHashMap.newKeySet()

class StdoutCapture extends edu.hm.hafner.analysis.ReaderFactory implements StandardOutputListener {
  final String taskName
  final StringWriter out

  StdoutCapture(final String taskName, final StringWriter out) {
    super(java.nio.charset.StandardCharsets.UTF_8)

    this.taskName = taskName
    this.out = out
  }

  @Override
  void onOutput(final CharSequence output) {
    out.append(output)
  }

  @Override
  String getFileName() {
    return this.taskName
  }

  @Override
  Reader create() {
    return new StringReader(this.out.toString())
  }
}

class TaskCaptureListener implements TaskExecutionListener {
  def parserRegistry = new edu.hm.hafner.analysis.registry.ParserRegistry()
  private final ThreadLocal<StandardOutputListener> state = ThreadLocal.withInitial { null }

  @Override
  void beforeExecute(Task task) {
    if (task instanceof AbstractCompile && task.hasProperty('outputReviewdogJson') && task.hasProperty('expectedReporters')) {
      def listener = new StdoutCapture(task.path, new StringWriter())
      // task.logging.addStandardOutputListener(listener)
      task.logging.addStandardErrorListener(listener)
      state.set(listener)
    }
  }

  @Override
  void afterExecute(final Task task, final TaskState state) {
    if (task instanceof AbstractCompile) {
      def oldCapture = this.state.get()
      this.state.remove()
      if (oldCapture != null) {
        // task.logging.removeStandardOutputListener(oldCapture)
        task.logging.removeStandardErrorListener(oldCapture)

        def parsers = task.expectedReporters.collect { parserRegistry.get(it).createParser() }
        def report = new edu.hm.hafner.analysis.Report(task.path, task.name)
        parsers.each { parser ->
          if (parser.accepts(oldCapture)) {
            report.addAll(parser.parse(oldCapture))
          }
        }
        // read contents of log
        logReportMessages(report)
        task.outputReviewdogJson.parentFile.mkdirs()
        task.outputReviewdogJson.withWriter('UTF-8') { writer ->
          reportToRdJson(report).each {
            writer.writeLine it
          }
        }
      }
    }

    if (task instanceof Test) {
      // prepare JUnit report, fill in file names if possible
    }
  }

  Collection<String> reportToRdJson(final edu.hm.hafner.analysis.Report report) {
    return report.collect { issue -> 
        [
          message: issue.message,
          location: [
            path: issue.absolutePath,
            range: [
              start: [
                line: issue.lineStart,
                column: issue.columnStart
              ],
              end: [
                line: issue.lineEnd,
                column: issue.columnEnd
              ]
            ]
          ],
          severity: severityToRd(issue.severity),
          source: [
            name: undefinedToNull(issue.originName)
          ],
          code: [
            value: undefinedToNull(issue.type)
          ]
        ]
      }.collect { groovy.json.JsonOutput.toJson(it) }
  }

  private String severityToRd(final edu.hm.hafner.analysis.Severity severity) {
    switch (severity.name) {
      case 'ERROR': 
      case 'HIGH':
        return 'ERROR'
      case 'NORMAL':
        return 'WARNING'
      case 'LOW':
      case 'INFO':
        return 'INFO'
      default:
        return 'UNKNOWN_SEVERITY'
    }
  }

  private String undefinedToNull(final String input) {
    if ('-'.equals(input)) {
      return null
    }
    return input
  } 

  void logReportMessages(final edu.hm.hafner.analysis.Report report) {
    report.infoMessages.each {
      println "::notice ::$it"
    }

    report.errorMessages.each {
      println "::error ::$it"
    }
  }
}

// Capture task output to a file
def taskCapture = new TaskCaptureListener()
gradle.addListener taskCapture

gradle.afterProject { project ->
  // Capture project directory
  projectDirs << project.projectDir

  // Log test task output
  project.tasks.withType(Test) {
    def testClassList = reports.junitXml.outputLocation.file('test-classpath.txt')
    outputs.file(testClassList)
    reports {
      junitXml {
        // Make sure we're enabled
        required = true
      }
    }

    doFirst {
      // Write all test class directories to a file in the report discord
      def testClassListFile = testClassList.get().asFile
      testExecutions.add(testClassListFile.parentFile)

      // The JUnit XML doesn't give us actual file names, so we have to link up the source files used to build these test tasks with the actual classpath
      def inputTasks = new java.util.ArrayDeque<Task>(testClassesDirs.buildDependencies.getDependencies(it))

      testClassListFile.withWriter('utf-8') { writer -> 
        Task next = null;
        while ((next = inputTasks.poll()) != null) {
          if (next instanceof SourceTask) {
            next.source.each { file -> 
                writer.writeLine file.absolutePath
            }
          } else {
            inputTasks.addAll next.taskDependencies.getDependencies(next)
          }
        }
      }
    }
  }

  // Capture checkstyle output
  project.tasks.withType(Checkstyle) {
    reports.xml.required = true

    doFirst {
      checkstyleReports << reports.xml.outputLocation.get().asFile
    }
  }

  // capture output of javac
  def layout = project.layout
  project.tasks.withType(JavaCompile) {
    it.ext.outputReviewdogJson = layout.buildDirectory.file("java-compile-output/${it.name}.jsonl").get().asFile
    it.ext.expectedReporters = ['error-prone', 'java'] // https://github.com/jenkinsci/analysis-model/blob/master/SUPPORTED-FORMATS.md
    doFirst {
      reviewdogJsons << it.outputReviewdogJson
    }
  }
}

// Provide JSON data to subsequent tasks
gradle.buildFinished {
    def json = groovy.json.JsonOutput.toJson([
      version: gradle.rootProject.version,
      projectDirs: projectDirs.collect { it.absolutePath },
      testExecutions: testExecutions.collect { it.absolutePath },
      checkstyleReports: checkstyleReports.collect { it.absolutePath },
      reviewdogJsons: reviewdogJsons.collect { it.absolutePath }
    ])
    println "::set-output name=project-metadata::${json}"
}